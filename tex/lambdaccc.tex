\section*{Simply typed lambda calculus}
The simply typed lambda calculus ($\lambda$-calculus) is essentially equivalent to a cartesian closed category in a sense we can make precise. Both are languages in which it is possible to express transformations via functions between objects with operations that express pairing, projection, and application.

The simply typed lambda calculus is made up of types, terms and equations as follows:
\begin{enumerate}
\item{Types:}
\begin{align*}
&\mbox{basic types: } A, B, \ldots\\
&\mbox{product types: } A \times B, \ldots\\ 
&\mbox{function types: } A \rightarrow B, \ldots
\end{align*}
\item{Terms:}
\begin{align*}
&\mbox{variables: } x, y, z, \ldots \colon A \mbox{ for each type } A,\\
&\mbox{constants: } a \colon A, b \colon B, \mbox{ for each type},\\
&\mbox{products: }\langle a, b \rangle \colon A \times B \mbox{ for } a:A \mbox{ and } b:B,\\
&\mbox{first projection: }\mbox{fst}(c) \colon A \mbox{ for } c \colon A \times B,\\
&\mbox{second projection: }\mbox{snd}(c) \colon A \mbox{ for } c \colon A \times B,\\
&\mbox{application: }ca \colon B \mbox{ for } c \colon A \rightarrow B \mbox{ and } a \colon A,\\
&\mbox{abstraction: }\lambda x. b \colon A \rightarrow B \mbox{ for } x \colon A \mbox{ and } b \colon B
\end{align*}
\item{Equations:}
\begin{align*}
            \mbox{fst}(\langle a, b \rangle) &= a\\
            \mbox{snd}(\langle a, b \rangle) &= b\\
            \langle \mbox{fst}(c), \mbox{snd}(c) \rangle &= c\\
            (\lambda x.b)a &= b[a/x]\\
            \lambda x.cx &= c, \mbox{ $x$ not in $c$ }\\
            \lambda x.b &= \lambda y.b [y/x], \mbox{ no $y$ in $b$ }
\end{align*}
\end{enumerate}
A variable reference $x$ is said to be \emph{bound} if it is inside of an abstraction binding $x$. For example $\lambda x. x$ is a term in which $x$ is bound whereas $\lambda y. x y$ is a term in which $x$ is unbound or \emph{free} and $y$ is bound. A term is said to be \emph{closed} if there are no unbound variables. Therefore, $\lambda x.x$ is a closed term whereas $\lambda y.xy$ is not. Terms are identified according to the equivalence relation $a \sim b$ generated by the equations above.

\section*{Categorical semantics for the simply typed lambda calculus}
A category can be associated to any particular instantiation of the lambda calculus with given types, variables and constants. To any such language $\mathcal{L}$ satisfying the defining equations of the simply typed lambda calculus, a cartesian closed category of types $\mathcal{C}(\mathcal{L})$ is determined by the following identifications
\begin{enumerate}
\item{objects: } types
\item{morphisms: } terms $c \colon A \rightarrow B$ that are identified for $c \sim c'$ given by the equivalence relation determined by the defining equations of $\lambda$-calculus. Two equivalence classes of terms $[a], [b]$ may be identified $[a] = [b]$ if and only if the terms they represent are equivalent, which is to say that  $\mathcal{L} \vdash a = b$.
\item{identities: } $1_A = \lambda x.x$ where $x \colon A$
\item{morphism composition: } $c \circ b = \lambda x.c(bx)$
\end{enumerate}
The unit laws, associativity of composition, the existence of products, terminal objects, and exponential objects can be verified from this set of identifications to prove that the category $\mathcal{C}(\mathcal{L})$ is cartesian closed.

If we refer to the set of basic types, terms, and equations as a \emph{theory}, $\mathcal{L}$, in the $\lambda$-calculus, then $\mathcal{C}(\mathcal{L})$ is the cartesian closed category presented by the generators (types and terms) and relations (equations) stated by the $\lambda$-calculus over $\mathcal{L}$. A model of a such a theory $\mathcal{L}$ in the $\lambda$-calculus in a cartesian closed category $\mathcal{C}$ is given by an assignment of types and terms in $\mathcal{L}$ to objects and morhphisms in $\mathcal{C}$:
\begin{align*}
X \mbox{ basic type } &\leadsto \llbracket X \rrbracket\\
b \colon A \rightarrow B \mbox{ basic term } &\leadsto \llbracket b \rrbracket \colon \llbracket A \rrbracket \rightarrow \llbracket B \rrbracket
\end{align*}
which can be naturally extended to the other types and terms that are built upon these. Moreover the equations associated to the theory $\mathcal{L}$ are required to be satisfied so that:
\begin{align*}
\mathcal{L} \vdash [a]=[b] \colon A \rightarrow B \Longrightarrow \llbracket a \rrbracket = \llbracket b \rrbracket \colon \llbracket A \rrbracket \rightarrow \llbracket B \rrbracket
\end{align*}
This semantic association between a theory $\mathcal{L}$ in $\lambda$-calculus and models of such theories in cartesian closed categories is referred to as \emph{denotational semantics} for the $\lambda$-calculus. Indeed, there is a logical completeness theorem associated to such semantics stating that for any theory $\mathcal{L}$ in the $\lambda$-calculus equivalence of terms is mirrored precisely by equivalence of the semantic interpretations of those terms in all models for $\mathcal{L}$ in cartesian closed categories. Although we will not expose the proof of this theorem here, it is important to note that it is not sufficient to consider only the category $\mathbf{Sets}$ as then there are some equations that hold among the models in that restricted context that cannot be proved in a theory of $\lambda$-calculus.