%!TEX root = ../notes.tex
\subsection*{Categorical semantics for type theory, more generally}
We have presented two particular cases of a more general paradigm referred to as categorical semantics (for logic or type theory). In a slightly more general situation we can imagine that a \emph{basic language} $\mathcal{L}$ consists of basic types and basic terms with type assignments \cite{Awodey2000}. A (type) \emph{theory} $\mathbb{T}$ consists of a set of basic type symbols, a set of basic terms, typed over the basic types, and a set of equations between terms in the language $\mathcal{L}[\mathbb{T}]$ of all terms over the basic language of basic types and terms.

A \emph{model} $\mathcal{M}$ of a theory $\mathbb{T}$ in a category $\mathcal{C}$ can be viewed as a functor $\mathcal{M} \colon \mathbb{T} \rightarrow \mathcal{C}$ that provides an interpretation of the types $\tau$ and terms $N(x) \colon \tau$ of $\mathcal{L}[\mathbb{T}]$ as objects $X$ and arrows $\llbracket N(x) \rrbracket \colon X \rightarrow \llbracket \tau \rrbracket$ in $\mathcal{C}$ such that the equations defining $\mathbb{T}$ between terms of $\mathcal{L}[\mathbb{T}]$ are satisfied by their interpretations in terms of \emph{commutative diagrams} (which define equations between paths) in $\mathcal{C}$. A model is said to be \emph{standard} if $\mathcal{C}$ is cartesian closed and the function types $\sigma \rightarrow \tau$ are always interpreted as exponential objects meaning that $\llbracket \sigma \rightarrow \tau \rrbracket = \llbracket \tau \rrbracket ^ {\llbracket \sigma \rrbracket}$.

A system of \emph{semantics} $\mathcal{S}$ for a type theory then consists of a class of models $\mathcal{M} \colon \mathbb{T} \rightarrow \mathcal{C}$ for each theory $\mathbb{T}$ in possibly different categories $\mathcal{C}$. $\mathcal{C}$-valued semantics refer to the collection of models that take values in a particular category $\mathcal{C}$.

A system of semantics $\mathcal{S}$ is said to be complete if the deductive calculus for syntactic equivalence is sound and complete with respect to $\mathcal{S}$. This means that for every theory $\mathbb{T}$ and any terms $M, N \in \mathcal{L}[\mathbb{T}]$, $\llbracket M \rrbracket_{\mathcal{M}} = \llbracket N \rrbracket_{\mathcal{M}}$ for every model $\mathcal{M} \in \mathcal{S}$ if and only if $\mathbb{T} \vdash M = N$.

\subsection*{The typed-type-free spectrum}
Although we have presented the type-free and the simply typed theories of $\lambda$-calculus as if the former is particular and the latter general\todo{Dana Scott suggested the relationship in which type-free or unityped is a specific case of the simply typed theory in \emph{Relating theories of the lambda calculus}. Barendregt challenges this point of view in his classic book on lambda calculus (see page 87).}, there is a sense in which we have observed two extreme points on a spectrum in which precisely the opposite may be the case \cite{Scott1980,Barendregt1985}. The sense in which the simply-typed theory is more general is that models of the type-free $\lambda$-calculus \emph{come from} cartesian closed categories with reflexive objects, wherein a single reflexive object can serve as a model of the type-free $\lambda$-calculus. Moreover, as we have described, the cartesian closed category itself with potentially many objects representing the simple types corresponds to the simply-typed $\lambda$-calculus. So from this point of view it appears that the type-free $\lambda$-calculus is a special case of the simply-typed wherein we restrict ourselves to one special type of object: a reflexive domain.

On the other hand the expressive power of these two languages suggests the opposite point of view. The simply-typed $\lambda$-calculus can represent only a proper subset of recursive functions whereas the type-free $\lambda$-calculus is capable of expressing any given recursive function. Of course, this additional expressive power comes with the potentially undesirable property of being able to express incomputable functions whereas it may be desirable never to do this.

In either case it is clear that the conceptual space between the simply-typed and the untyped $\lambda$-calculi may contain a more desirable system in which linguistic expressive power can be elevated beyond that of the simply-typed case without incorporating the ability to accidentally or intentionally express constructs that aren't computable. Indeed much research has been performed with exceptionally important consequences for the future of computation. We expect that incorporating ideas from modern type theories will enable substantial refinement of the expression of the functional closure property that appears to be essential to the existence of evolvable systems and this may increase the degree to which theoretical evolutionary biology and programming language theory interact.
